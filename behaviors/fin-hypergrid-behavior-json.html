<!--

The `fin-hypergrid-behavior-json` element is a custom Polymer web component used to support the openfin [fin-hypergrid](http://github.com/openfin/fin-hypergrid) component.

@group OpenFin hypergrid
@element fin-hypergrid-behavior-json
@homepage http://github.com/openfin/fin-hypergrid
-->

<polymer-element name="fin-hypergrid-behavior-json" extends="fin-hypergrid-behavior-default">
  <template></template>
  <script>

/*jshint  bitwise: false */
'use strict';

(function() {

 window.adaptiveSort = (function(){
    /*jshint bitwise: false*/
    /*jshint noempty: false*/

    /**
    * Sorts an array of integers using the AdaptiveSort algorithm.
    * @param {Array.<number>} items Array of items to be sorted.
    */

    /*
    * Adaptive merge sort algorithm
    * Implementation: Eugene Scherba, 11/9/2010
    *
    * This is a stable sort algorithm, similar to merge sort except
    * that it takes advantage of partially ordered "chains" (Donald
    * Knuth refers to these structures as "runs"). Performance of this
    * algorithm is directly dependent on the amount of preexisting
    * partial ordering, however generally it is pretty good even on
    * completely random arrays.
    *
    * Time complexity: O(n) if array is already sorted,
    * O(n.log(n)) in a worst case which should be rare.
    * Space complexity: O(n) in worst case, usually around O(n/2).
    */

    function merge(left, right, property) {
        /*
        * Given two non-empty ordered arrays (chains), returns a new
        * array containing an ordered union of the input chains.
        */
        var left_len = left.length,
        right_len = right.length,
        left_val,
        right_val,
        result;
        if (left[left_len - 1][property] <= (right_val = right[0])[property]) {
            result = left.concat(right);
        } else if (right[right_len - 1][property] < (left_val = left[0])[property]) {
            result = right.concat(left);
        } else {
            /* By this point, we know that the left and the right
            * arrays overlap by at least one element and simple
            * concatenation will not suffice to merge them. */

            result = new Array(left_len + right_len);
            var k = 0, h = 0;
            while (true) {
                if (right_val[property] < left_val[property]) {
                    result[k + h] = right_val;
                    if (++h < right_len) {
                        right_val = right[h];
                    } else {
                        while (k < left_len) {
                            result[k + h] = left[k++];
                        }
                        break;
                    }
                } else {
                    result[k + h] = left_val;
                    if (++k < left_len) {
                        left_val = left[k];
                    } else {
                        while (h < right_len) {
                            result[k + h] = right[h++];
                        }
                        break;
                    }
                }
            }
        }
        //setting array length to zero effectively removes the array from
        //memory (older versions of Firefox would leak unless these arrays
        //were reset).
        left.length = 0;
        right.length = 0;
        return result;
    }

    function find_fchain(arr, offset, limit, property) {
        /*
        * Given an array and offset equal to indexOf(elA), find
        * the (indexOf(elZ) + 1) of an element elZ in the array,
        * such that all elements elA..elZ form a non-strict
        * forward-ordered chain.
        */
        var tmp, succ;
        for (tmp = arr[offset];
            ++offset < limit && tmp[property] <= (succ = arr[offset])[property];
            tmp = succ
        ) {}
        return offset;
    }

    function find_strict_rchain(arr, offset, limit, property) {
        /*
        * Given an array and offset equal to indexOf(elA), find
        * the (indexOf(elZ) + 1) of an element elZ in the array,
        * such that all elements elA..elZ form a strict
        * reverse-ordered chain.
        */
        var tmp, succ;
        for (tmp = arr[offset];
            ++offset < limit && (succ = arr[offset])[property] < tmp[property];
            tmp = succ
        ) {}
        return offset;
    }

    function chain_unit(arr, property) {
        // Step 1: return an array of chain arrays
        // expecting data in reverse order
        var terminus,
        len = arr.length,
        tmp = [],
        f = find_strict_rchain;

        for (var k = 0; k < len; k = terminus) {
            // try to find a chain (ordered sequence of at least
            // two elements) using a default function first:

            terminus = f(arr, k, len, property);
            if (terminus - k > 1) {
                tmp.push(
                    (f === find_strict_rchain) ?
                    arr.slice(k, terminus).reverse() :
                    arr.slice(k, terminus)
                );
            } else if (f === find_strict_rchain) {
                /* searched for a reverse chain and found none:
                * switch default function to forward and look
                * for a forward chain at k + 1: */

                tmp.push(arr.slice(k, ++terminus));
                f = find_fchain;
            } else {
                /* searched for a forward chain and found none:
                * switch default function to reverse and look
                * for a reverse chain at k + 1: */

                tmp.push(arr.slice(k, ++terminus).reverse());
                f = find_strict_rchain;
            }
        }
        return tmp;
    }

    function chain_join(tmp, property) {
        // Step 2: join all chains
        var j = tmp.length;
        if (j < 1) { return tmp; }

        // note: we reduce the size of the array after each iteration,
        // which is not really necessary (could be done at once at the end).
        for (; j > 1; tmp.length = j) {
            var k, lim = j - 2;
            // At this point, lim == tmp.length - 2, so tmp[k + 1]
            // is always defined for any k in [0, lim)
            for (j = 0, k = 0; k < lim; k = j << 1) {
                tmp[j++] = merge(tmp[k], tmp[k + 1], property);
            }
            // Last pair is special -- its treatment depends on the initial
            // parity of j, which is the same as the current parity of lim.
            tmp[j++] = (k > lim) ? tmp[k] : merge(tmp[k], tmp[k + 1], property);
        }
        var result = tmp.shift();
        return result;
    }

    return function (arr, property) {

        // immutable version -- store result in a separate location
        return chain_join(chain_unit(arr, property), property);

        // mutable (standard) version -- store result in-place
        //var result = chain_join(chain_unit(arr));
        //for (var k = 0, len = arr.length; k < len; k++) {
        //    arr[k] = result[k];
        //}
        //result.length = 0;
        //return arr;
    };

})();



    Polymer({ /* jslint ignore:line */

        sorted: {},
        sortStates: [' ', ' ^', ' v'],
        dataIndexes: [],
        data: [],
        headers: [],
        fields: [],

        setHeaders: function(headerLabels) {
            this.headers = headerLabels;
        },

        setFields: function(fieldNames) {
            this.fields = fieldNames;
        },

        setData: function(jsonData) {
            this.data = jsonData;
            this.initDataIndexes();
            this.changed();
        },

        initDataIndexes: function() {
            //initialize the index cache
            for (var i = 0; i < this.data.length; i++) {
                this.data[i].__si = i;
                this.data[i].__i = i;
            }
        },

        getValue: function(x, y) {
            return this.data[y][this.fields[x]];
        },

        setValue: function(x, y, value) {
            this.data[y][this.fields[x]] = value;
        },

        getFixedRowValue: function(x, y) {
            var sortIndex = this.sorted[x] || 0;
            return this.headers[x] + this.sortStates[sortIndex];
        },

        getFixedColCount: function() {
            return 1;
        },

        getRowCount: function() {
            return this.data.length;
        },

        getColCount: function() {
            return this.fields.length;
        },

        fixedRowClicked: function(grid, mouse) {
            var colIndex = this.scrollPositionX + mouse.gridCell.x - this.getFixedColCount();
            this.toggleSort(colIndex);
        },

        toggleSort: function(colIndex) {
            this.grid.clearSelections();
            if (colIndex >= this.fields.length) {
                return;
            }
            var current = this.sorted[colIndex] || 0;
            var stateCount = this.sortStates.length;
            var sortStateIndex = (current + 1) % stateCount;
            for (var i = 0; i < this.fields.length; i++) {
                this.sorted[i] = 0;
            }
            this.sorted[colIndex] = sortStateIndex;
            var colName = this.fields[colIndex];
            if (sortStateIndex === 0) {
                var newData = [];
                newData[this.data.length-1] = {};
                var each = {};
                for (var i = 0; i < this.data.length; i++) {
                    each = this.data[i];
                    newData[each.__si] = each;
                }
                this.data = newData;
            } else if (sortStateIndex === 1) {
                // var av, bv;
                // this.data.sort(function (a, b) {
                //   av = a[colName];
                //   bv = b[colName];
                //   if (av === bv) {
                //     return a.__i - b.__i;
                //   }
                //   if (av < bv) {
                //     return -1;
                //   }
                //   return 1;
                //});

                this.data = adaptiveSort(this.data, colName);

            } else {
                this.data = this.data.reverse();
            }
            for (var i = 0; i < this.data.length; i++) {
                this.data[i].__i = i;
            }
            this.changed();
        }

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>
